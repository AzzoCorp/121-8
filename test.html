function addGeoJSONLayer(geojson, style, layerName) {
  var geometries = maptalks.GeoJSON.toGeometry(geojson);
  var vectorLayer = new maptalks.VectorLayer(layerName, { enableAltitude: true }).addTo(map);
  var labelLayer = new maptalks.VectorLayer(layerName + '_labels', {
    collision: true // Activer la détection de collision pour la couche de labels
  }).addTo(map);

  var shadowSymbol = {
    lineColor: '#999999',
    lineDasharray: [10, 5, 5],
    lineWidth: 2,
    polygonFill: '#999999',
    polygonOpacity: 1,
    shadowBlur: 30, // Ajouter un flou à l'ombre
    shadowColor: 'rgba(0, 0, 0, 1)', // Couleur de l'ombre avec transparence
    shadowOffsetX: 0, // Décalage horizontal de l'ombre
    shadowOffsetY: 0  // Décalage vertical de l'ombre
  };
  var shadows = [];

  geometries.forEach(geometry => {
    var properties = geometry.getProperties();
    var areaText = '';
    if (layerName === 'depotsLayer') {
      var depots = properties.depots && properties.depots[0]; // Vérifier si depots et le premier élément existent
      areaText = depots ? depots[7] : ''; // Supposer que le 8ème élément est à l'index 7
    } else if (layerName === 'favorablesLayer') {
      var decisions = properties.decisions && properties.decisions[0]; // Vérifier si decisions et le premier élément existent
      areaText = decisions ? decisions[7] : ''; // Supposer que le 8ème élément est à l'index 7
    }

    console.log('Texte de la surface pour ' + layerName + ':', areaText);
    var altitude = extractSquareMeters(areaText) / 50; // Diviser par 50 pour un nombre plus réaliste
    console.log('Altitude calculée pour ' + layerName + ':', altitude);

    // S'assurer que les propriétés incluent l'altitude
    properties.altitude = altitude;
    geometry.setProperties(properties);

    // Définir le symbole sans altitude
    geometry.setSymbol({
      'lineColor': style.lineColor,
      'lineWidth': style.lineWidth,
      'polygonFill': style.polygonFill,
      'polygonOpacity': style.polygonOpacity
    });

    vectorLayer.addGeometry(geometry);

    // Créer la géométrie d'ombre
    var shadow = geometry.copy().setSymbol(shadowSymbol);
    shadow.setProperties({ altitude: 0 }); // Définir l'altitude de l'ombre à 0
    shadows.push(shadow);

    var center = geometry.getCenter();
    var label = new maptalks.Label(properties.numero + ' ' + properties.section, center, {
      'textSymbol': {
        'textFaceName': 'monospace',
        'textFill': '#34495e',
        'textHorizontalAlignment': 'center',
        'textVerticalAlignment': 'middle',
        'textWeight': 'bold' // Rendre le texte en gras
      }
    });
    labelLayer.addGeometry(label);
  });

  // Ajouter les ombres à une nouvelle couche et les mettre en arrière-plan
  new maptalks.VectorLayer(layerName + '_shadows', shadows, { enableAltitude: true }).addTo(map).bringToBack();

  // Ajouter un écouteur d'événement zoomend pour contrôler la visibilité des labels
  map.on('zoomend', function() {
    var zoom = map.getZoom();
    if (zoom >= 12) {
      labelLayer.show();
    } else {
      labelLayer.hide();
    }
  });

  // Vérification initiale de la visibilité
  if (map.getZoom() < 12) {
    labelLayer.hide();
  }

  // Ajouter un effet de flou aux polygones du calque favorablesLayer
  if (layerName === 'favorablesLayer') {
    var blurLayer = new maptalks.VectorLayer(layerName + '_blur', { enableAltitude: true }).addTo(map);
    geometries.forEach(geometry => {
      var blurSymbol = {
        'lineColor': 'rgba(0, 0, 0, 0)', // Pas de bordure
        'polygonFill': 'rgba(0, 156, 255, 0.5)', // Couleur semi-transparente
        'polygonOpacity': 0.5
      };
      for (var i = 1; i <= 5; i++) { // Ajouter plusieurs copies pour simuler le flou
        var blurGeometry = geometry.copy().translate(i, i).setSymbol(blurSymbol);
        blurLayer.addGeometry(blurGeometry);
      }
    });
  }
}

// Définir les styles
var depotsStyle = {
  'lineColor' : '#030000',
  'lineWidth' : 0.5,
  'polygonFill' : '#ff00fe',
  'polygonOpacity' : 1
};

var favorablesStyle = {
  'lineColor' : '#030000',
  'lineWidth' : 0.5,
  'polygonFill' : '#009cff',
  'polygonOpacity' : 1
};

// Ajouter la couche des dépôts
addGeoJSONLayer(depots, depotsStyle, 'depotsLayer');

// Ajouter la couche des favorables
addGeoJSONLayer(favorables, favorablesStyle, 'favorablesLayer');
